/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include"STM32F103C6_GPIO_DRIVER.h"
#include"STM32F103X6.h"
#include"KEYPAD.h"
#include"lcd.h"
#define ZERO	0x01
#define ONE		0x79
#define TWO		0x24
#define THREE 	0x30
#define FOUR 	0x4C
#define FIVE 	0x12
#define SIX 	0x02
#define SEVEN 	0x19
#define EIGHT 	0x00
#define NINE 	0x10



void Clock_init(){
	//ENABLE CLOCK GPIOA
	RCC_GPIOA_CLK_EN();
	//ENABLE CLOCK GPIOB
	RCC_GPIOB_CLK_EN();


}

void GPIO_init(){
	GPIO_PINCONFIG_T PINCFG;


	//PA1 AS INPUT HIGH IMPEDANCE(FLOATING)
	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN9;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);


	//PB1 AS OUTPUT PUSH-PULL MODE
	//CNF PISH PULL OUTPUT GENERAL REGISTER
	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN10;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);




	//PA13 AS INPUT HIGH IMPEDANCE(FLOATING)
	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN11;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);

	//PB13 AS OUTPUT PUSH-PULL MODE
	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN12;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);

	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN13;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);

	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN14;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);

	PINCFG.GPIO_PIN_NUMBER = GPIO_PIN15;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	MCAL_GPIO_INIT(GPIOB, &PINCFG);
}
void wait_ms(uint32_t time) {
	uint32_t i, j;
	for (i = 0; i < time; i++)
		for (j = 0; j < 255; j++)
			;
}
int main(void) {

	Clock_init();
	LCD_INIT();
	unsigned char key_pressed;
	LCD_WRITE_STRING("HEY");
	wait_ms(30);
	LCD_CLEAR_SCREEN();
	GPIO_init();
	unsigned char LCD_DISPLAY [11] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};
	unsigned char DISPLAY [11] = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, ZERO};
	for (unsigned char i = 0; i < 11; i++) {
		LCD_WRITE_CHAR(LCD_DISPLAY[i]);
		MCAL_GPIO_WRITEPORT(GPIOB, DISPLAY[i] << 9); /* write data on to the LED port */
		wait_ms(100);
		/* wait for 1 second */
	}
//	MCAL_GPIO_WritePort(GPIOB, 0xDE);
//	wait_ms(100);
	LCD_CLEAR_SCREEN();
	Keypad_init();
	LCD_WRITE_STRING("Keypad is ready");
	wait_ms(30);
	LCD_CLEAR_SCREEN();

	while (1) {

		key_pressed = Keypad_getkey();
		switch (key_pressed) {
		case 'A':
			break;
		case '?':
			LCD_CLEAR_SCREEN();
			break;
		default:
			LCD_WRITE_CHAR(key_pressed);
			break;
		}
	}
}
		/*int main(void)
		{
			Clock_init();
			GPIO_init();




			while(1)	{
				//PA1 CONNECTED EXTERNAL PUR (PULL UP REGISTER)
				if	(MCAL_GPIO_READPIN(GPIOA, GPIO_PIN1)	==	0) 		//THAT WE PRESS
				{
					MCAL_GPIO_TOGGLEPIN(GPIOB, GPIO_PIN1);

					while(MCAL_GPIO_READPIN(GPIOA, GPIO_PIN1)	==	0);		//FOR SINGLE PRESS IF CONDITION ALAWYS TRUE
				}
				//PA13 CONNECTED EXTERNAL PDR (PULL DOWN REGISTER)
				if	(MCAL_GPIO_READPIN(GPIOA, GPIO_PIN13)	==	1)			// ==1 BECAUSE IT IS PULL DOWN REGISTER
				{
					MCAL_GPIO_TOGGLEPIN(GPIOB, GPIO_PIN13);
						}
				my_wait(1);

			}
		}


		*/
