/*
 * STM32F103C6_USART_DRIVER.c
 *
 *  Created on: Jul 7, 2023
 *      Author: Andrew Nasser
 */

#include "STM32F103X6.h"
#include "STM32F103C6_USART_DRIVER.h"

USART_CONFIG* GLOBAL_UART_CONFIG=NULL;
/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_INIT
 * BRIEF     ----> INTIALIZE UART (ASYNC ONLY)
 * PARAM1[IN]----> USARTx
 * PARAM1[IN]----> CONFIG ALL UART CONFIGURATION
 * RETAVAL	 ----> POSITION IN CR REGISTER
 * NOTE		 ----> SUPPORT ASYNC WITH CLCK OUT 8MHZ
 *
 */
void MCAL_USART_INIT(USART_Typedef *USARTx ,USART_CONFIG *USART_CONFIG ){

	uint32_t PCLCK , BRR;

	GLOBAL_UART_CONFIG=USART_CONFIG;		//PREVENT AS BACKUP IF FUNCTION NEED INFORMATIO

	//ENABLE CLOCK FOR UART
	if(USARTx==USART1)
		RCC_USART1_CLK_EN();
	else if(USARTx==USART2)
		RCC_USART2_CLK_EN();
	else if(USARTx==USART3)
		RCC_USART3_CLK_EN();

	//ENABLE USART MODULE FROM CR1 REGISTER BIT 13
	USARTx->CR1 |= 1<<13;

	//ENABLE TX RX MODE SET BIT 2 OR 3 OR EACH FROM CR1 REGISTER
	USARTx->CR1 |= USART_CONFIG->USART_MODE;

	//CHOOSE THE PAYLOAD LENGTH SETBIT 13 FROM CR1 REGISTER
	USARTx->CR1 |= USART_CONFIG->USART_PAYLOAD_LENGHTH;

	//CONFIGURE PARITY CTRL SET BIT 9 FROM CR1 REGISTER
	USARTx->CR1 |= USART_CONFIG->USART_PARITY;

	//CONFIGURE NUMBER OF STOP BITS SET BIT 12,13 FROM CR2 REGISTER
	USARTx->CR2 |= USART_CONFIG->USART_STOPBITS;

	//USED OF FLOW CTRL
	USARTx->CR3 |= USART_CONFIG->USART_FLOWCTL;

	//CONFIGURE BAUD RATE (PCLCK1 --> USART2,3    PCLCK2--> USART1)

	if(USARTx==USART1)
		PCLCK=MCAL_RCC_PCLCK2_GETFREQ();
	else
		PCLCK=MCAL_RCC_PCLCK1_GETFREQ();

	BRR=UART_BRR_Register(PCLCK,USART_CONFIG->USART_BAUDRATE);
	USARTx->BRR=BRR;

	//ENABLE , DISABLE INTURREPT
	if(USART_CONFIG->USART_IRQHANDLER |= USART_IRQ_ENABLE_NVIC)
		USARTx->CR1 |= USART_CONFIG->USART_IRQHANDLER;
	//ENABLE NVIC
	if(USARTx==USART1)
		NVIC_IRQ37_EUSART1_ENABLE;
	else if(USARTx==USART2)
		NVIC_IRQ38_EUSART2_ENABLE;
	else if(USARTx==USART3)
		NVIC_IRQ39_EUSART3_ENABLE;



}



/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_DEINIT
 * BRIEF     ----> USE TO DEINIT USART
 * PARAM1[IN]----> USART X WHICH X CAN BE 1,2,3
 * RETAVAL	 ----> NONE
 * NOTE		 ----> DISABLE CLCK NVIC INTERRUPT AND RESET CLCK
 *
 */
void MCAL_USART_DEINIT(USART_Typedef *USARTx ){
	if(USARTx==USART1){
		RCC_USART1_CLK_RESET();
		NVIC_IRQ37_EUSART1_DISABLE;
	}
	else if(USARTx==USART2){
		RCC_USART2_CLK_RESET();
		NVIC_IRQ38_EUSART2_DISABLE;
	}
	else if(USARTx==USART3){
			RCC_USART3_CLK_RESET();
			NVIC_IRQ39_EUSART3_DISABLE;
		}

}



/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_GPIO_SETPIN
 * BRIEF     ----> USE TO SET PIN OF GPIO TO USED IN UART
 * PARAM1[IN]----> USART X WHICH X CAN BE 1,2,3
 * RETAVAL	 ---->NONE
 * NOTE		 ----> NONE
 *
 */
void MCAL_USART_GPIO_SETPIN(USART_Typedef *USARTx ){

	GPIO_PINCONFIG_T PINCFG ;

		if ( USARTx == USART1 )
		{
			//PA9 TX
			//PA10 RX
			//PA11 CTS
			//PA12 RTS

			//PA9 TX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN9;
			PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
			PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
			MCAL_GPIO_INIT(GPIOA, &PINCFG);

			//PA10 RX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN10;
			PINCFG.GPIO_MODE = GPIO_MODE_FLOATING;
			MCAL_GPIO_INIT(GPIOA, &PINCFG);

			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_CTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS ){
				//PA11 CTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN11;
				PINCFG.GPIO_MODE = GPIO_MODE_FLOATING;
				MCAL_GPIO_INIT(GPIOA, &PINCFG);
			}


			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS )
			{
				//PA12 RTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN12;
				PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
				PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
				MCAL_GPIO_INIT(GPIOA, &PINCFG);

			}
		}
		else if ( USARTx == USART2 )
		{
			//PA2 TX
			//PA3 RX
			//PA0 CTS
			//PA1 RTS


			//PA2 TX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN2;
			PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
			PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
			MCAL_GPIO_INIT(GPIOA, &PINCFG);

			//PA3 RX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN3;
			PINCFG.GPIO_MODE = GPIO_MODE_AF_INPUT;
			MCAL_GPIO_INIT(GPIOA, &PINCFG);

			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_CTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS  )
			{
				//PA0 CTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN0;
				PINCFG.GPIO_MODE = GPIO_MODE_FLOATING;
				MCAL_GPIO_INIT(GPIOA, &PINCFG);
			}

			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS  )
			{
				//PA1 RTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN1;
				PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
				PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
				MCAL_GPIO_INIT(GPIOA, &PINCFG);
			}
		}
		else if ( USARTx == USART3 )
		{
			//PB10 TX
			//PB11 RX
			//PB13 CTS
			//PA14 RTS



			//PB10 TX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN10;
			PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
			PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
			MCAL_GPIO_INIT(GPIOB, &PINCFG);

			//PB11 RX
			PINCFG.GPIO_PIN_NUMBER = GPIO_PIN11;
			PINCFG.GPIO_MODE = GPIO_MODE_AF_INPUT;
			MCAL_GPIO_INIT(GPIOB, &PINCFG);

			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_CTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS )
			{
				//PB13 CTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN13;
				PINCFG.GPIO_MODE = GPIO_MODE_FLOATING;
				MCAL_GPIO_INIT(GPIOB, &PINCFG);
			}
			if (GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS  ||GLOBAL_UART_CONFIG->USART_FLOWCTL ==USART_FLOWCTL_RTS_CTS )
			{
				//PA14 RTS
				PINCFG.GPIO_PIN_NUMBER = GPIO_PIN14;
				PINCFG.GPIO_MODE = GPIO_MODE_AF_PUSH_PULL;
				PINCFG.GPIO_SPEED_OUTPUT = GPIO_SPEED_10M;
				MCAL_GPIO_INIT(GPIOB, &PINCFG);

			}
		}

}


/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_SEND
 * BRIEF     ----> SEND BUFFER ON UART
 * PARAM1[IN]----> USART X WHICH X CAN BE 1,2,3
 * PARAM2[IN]----> BUFFER VAR
 * PARAM3[IN]----> ENABLE OR DISABLE POLLING
 * RETAVAL	 ----> NONE
 * NOTE		 ----> EACH PIN HAVE 4 BIT IN CR REGISTER
 *
 */
void MCAL_USART_SEND(USART_Typedef *USARTx, uint16_t *PTX_BUFFER,enum POLLING_MECHANISM POLLINGEN ){
	//IF USER OPEN POLLING MECHANISM WE WILL POLL IT
	if(POLLINGEN== enable){
		while(!(USARTx->SR & 1<<7));
	}
	//CHECK USART WORD LENGTH
	/*When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),
	the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect
	because it is replaced by the parity*/
	if(GLOBAL_UART_CONFIG->USART_PAYLOAD_LENGHTH == USART_PAYLOAD_LENGHTH9B){
		USARTx->DR =(*PTX_BUFFER & (uint16_t)0x01FF);
	}
	else
		USARTx->DR =(*PTX_BUFFER & (uint8_t)0x0FF);
}







/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_RECIEVE
 * BRIEF     ----> RECIEVE BUFFER ON UART
 * PARAM1[IN]---->  USART X WHICH X CAN BE 1,2,3
 * RETAVAL	 ----> NONE
 * NOTE		 ----> EACH PIN HAVE 4 BIT IN CR REGISTER
 *
 */
void MCAL_USART_RECIEVE(USART_Typedef *USARTx, uint16_t *PRX_BUFFER,enum POLLING_MECHANISM POLLINGEN ){

	//LOOP OVER UNTIL LEN OF NUMBER ARE TRANSFERRED
		//WAIT UNTIL RXNE FLAG SET IN SR REGISTER
		if (POLLINGEN == enable)
		{
			while( ! (USARTx->SR & 1<<5 ));
		}


		//CHECK WORDLENGTH ITEM FOR 9BIT or 8BIT IN A FRAME
		if (GLOBAL_UART_CONFIG->USART_PAYLOAD_LENGHTH == USART_PAYLOAD_LENGHTH9B)
		{
			if (GLOBAL_UART_CONFIG->USART_PARITY ==USART_PARITY_NONE)
			{
				//NO PARITY ---> 9B ALL IS DATA
				*((uint16_t*) PRX_BUFFER) = USARTx->DR ;

			}else
			{
				//PARITY USED, SO, 8 BIT WILL BE OF USER DATA , 1 BIT IS PARITY
				*((uint16_t*) PRX_BUFFER) = ( USARTx->DR  & (uint8_t)0xFF );

			}

		}else
		{
			//8 BIT DATA
			if (GLOBAL_UART_CONFIG->USART_PARITY ==USART_PARITY_NONE)
			{
				//NO PARITY ----> 8B IS ALL DATA
				*((uint16_t*) PRX_BUFFER) = ( USARTx->DR  & (uint8_t)0xFF ) ;

			}else
			{
				//PARITY USED, SO, 7 BIT WILL BE OF USER DATA , 1 BIT IS PARITY
				*((uint16_t*) PRX_BUFFER) = ( USARTx->DR  & (uint8_t)0X7F );

			}
		}

}




/*======================================================================================================
 * FUNC NAME ----> MCAL_USART_TC
 * BRIEF     ---->  CHECK ALL DATA TRANSMITT OR NOT
 * PARAM1[IN]----> USART X WHICH X CAN BE 1,2,3
 * RETAVAL	 ----> NONE
 * NOTE		 ----> NONE
 *
 */
void MCAL_USART_TC(USART_Typedef *USARTx ){

while(USARTx->SR & 1<<6);
}



//ISR
void USART1_IRQHandler (void)
{

	GLOBAL_UART_CONFIG->P_IRQ_CALLBACK() ;

}

void USART2_IRQHandler (void)
{
	GLOBAL_UART_CONFIG->P_IRQ_CALLBACK() ;

}
void USART3_IRQHandler (void)
{
	GLOBAL_UART_CONFIG->P_IRQ_CALLBACK () ;


}

