/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


//#define	MCU_AS_MASTER		//FOR MCU ACT AS MASTER
//#define	MCU_AS_SLAVE		//FOR MCU ACT AS SLAVE

#include "STM103C6_HEADERS.H"

uint8_t DATA;
//unsigned int CH;

void Clock_init(){
	//ENABLE CLOCK GPIOA
	RCC_GPIOA_CLK_EN();
	//ENABLE CLOCK GPIOB
	RCC_GPIOB_CLK_EN();
	AFIO_CLK_EN();


}
/*void wait_ms(uint32_t time) {
	uint32_t i, j;
	for (i = 0; i < time; i++)
		for (j = 0; j < 255; j++)
			;
}


void EXTI9_CALLING(void){
	IRQ_FLAG=1;
	LCD_WRITE_STRING("IRQ_EXTI9 IS HAPPEN -|-");
	wait_ms(1000);
}

*/


void I2C1_IRQ_Call ( SLAVE_STATE STATE)
{
	switch(STATE)
	{
	case I2C_EV_STOP:
		I2C1->SR1 &=~(I2C_SR1_AF) ;
		break ;
	case I2C_EV_ADDR_MATCHED:
		break ;
	case I2C_EV_DATA_REQ:
		MCAL_I2C_SLAVE_TX(I2C1, DATA) ;
		break ;
	case I2C_DATA_REC:
		DATA=MCAL_I2C_SLAVE_RX(I2C1) ;
		break ;
	}
}

/*void SPI_IRQ_Callback(struct S_IRQ_SRC IRQ_SRC){

#ifdef MCU_AS_SLAVE

	if(IRQ_SRC.RXNE){
		CH=0xf;
		MCAL_SPI_TX_RX(SPI1,&CH,POLLING_DISABLE);
		MCAL_USART_SEND(USART1, &CH, enable);

	}

#endif


}
void UART_IRQ_Callback (void){
	MCAL_USART_RECIEVE(USART1, &CH, disable);
	MCAL_USART_SEND(USART1, &CH, enable);

	//SPI
	MCAL_GPIO_WRITEPIN(GPIOA, GPIO_PIN4, 0);		//TO MAKE SLAVE EQUAL 0
	MCAL_SPI_TX_RX(SPI1, &CH, POLLING_ENABLE);
	MCAL_GPIO_WRITEPIN(GPIOA, GPIO_PIN4, 1);		//TO MAKE SLAVE EQUAL 1


}
*/
int main(){


	Clock_init();
	/*USART_CONFIG uartCFG ;
	uartCFG.USART_BAUDRATE = USART_BAUDRATE_115200 ;
	uartCFG.USART_FLOWCTL = USART_FLOWCTL_NONE ;
	uartCFG.USART_IRQHANDLER = USART_IRQ_ENABLE_RXNE ;
	uartCFG.P_IRQ_CALLBACK =UART_IRQ_Callback ;
	uartCFG.USART_PARITY=USART_PARITY_NONE ;
	uartCFG.USART_PAYLOAD_LENGHTH = USART_PAYLOAD_LENGHTH8B;
	uartCFG.USART_STOPBITS = USART_STOPBITS_ONE ;
	uartCFG.USART_MODE = USART_MODE_TX_RX ;

	MCAL_USART_INIT(USART1, &uartCFG);
	MCAL_USART_GPIO_SETPIN(USART1);



	//FOR SPI COMMON

	SPI_CONFIG SPICFG;
	SPICFG.SPI_CLCK_POLARITY= SPI_POLARITY_HIGH;
	SPICFG.SPI__CLCK_PHASE = SPI_PHASE_2ST;
	SPICFG.SPI_DATA_SIZE = SPI_8BIT_DATA;
	SPICFG.SPI_FRAME_FORMAT = SPI_MSB;
	SPICFG.SPI_BAUDRATE = SPI_BAUDRATE_PRESC8;
	SPICFG.SPI_COMMUNICATION_MODE = SPI_2LINE;



#ifdef MCU_AS_MASTER

	SPICFG.SPI_DEVICE_MODE=SPI_MASTER_MODE;
	SPICFG.SPI_IRQ_ENABLE=SPI_IRQ_EN_NONE;
	SPICFG.SPI_NSS=SPI_NSS_SW_SET;
	SPICFG.P_IRQ_CALLBACK=NULL;


	GPIO_PINCONFIG_T PINCFG;
	PINCFG.GPIO_PIN_NUMBER=GPIO_PIN4;
	PINCFG.GPIO_SPEED_OUTPUT=GPIO_SPEED_10M;
	PINCFG.GPIO_MODE=GPIO_MODE_PUSH_PULL;
	MCAL_GPIO_INIT(GPIOA, &PINCFG);

	//FORCE SLAVE TO BE HIGH
	MCAL_GPIO_WRITEPIN(GPIOA, GPIO_PIN4, 1);


#endif


#ifdef MCU_AS_SLAVE
	SPICFG.SPI_DEVICE_MODE=SPI_SLAVE_MODE;
	SPICFG.SPI_IRQ_ENABLE=SPI_IRQ_EN_RXNEIE;
	SPICFG.SPI_NSS=SPI_NSS_HW_SLAVE;
	SPICFG.P_IRQ_CALLBACK=SPI_IRQ_Callback;

#endif



	MCAL_SPI_INIT(SPI1, &SPICFG);
	MCAL_SPI_GPIO_SETPIN(SPI1);
*/


		uint8_t DATA1[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
		uint8_t DATA2[7]= {0};

		EEPROM_INIT();
		EEPROM_WRITE_DATA(0xAF, DATA1, 7);
		EEPROM_READ_DATA(0xAF, DATA2, 7);

		DATA1[0] = 0xA;
		DATA1[1] = 0xB;
		DATA1[2] = 0xC;
		DATA1[3] = 0xD;

		EEPROM_WRITE_DATA(0xFFF, DATA1, 4);
		EEPROM_READ_DATA(0xFFF, DATA2, 4);

		while (1)
		{
		}



	while(1){


	}

}
